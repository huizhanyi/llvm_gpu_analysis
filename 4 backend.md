## 引言
bitcode文件生成后，经过优化进入后端，这是bitcode文件到ptx文件的生成过程
clang的生成过程使用如下的命令：
```
"/home/yhz/llvm-project/build-debug/bin/clang-18" -cc1 -triple nvptx64-nvidia-cuda -aux-triple x86_64-unknown-linux-gnu -S -dumpdir axpy- -save-temps=cwd -disable-free -clear-ast-before-backend -main-file-name axpy.cu -mrelocation-model static -mframe-pointer=all -fno-rounding-math -no-integrated-as -aux-target-cpu x86-64 -fcuda-is-device -mllvm -enable-memcpyopt-without-libcalls -fcuda-allow-variadic-functions -mlink-builtin-bitcode /usr/local/cuda-12.3/nvvm/libdevice/libdevice.10.bc -target-sdk-version=12.3 -target-cpu sm_60 -target-feature +ptx83 -debugger-tuning=gdb -fno-dwarf-directory-asm -fdebug-compilation-dir=/home/yhz/cuda -v -resource-dir /home/yhz/llvm-project/build-debug/lib/clang/18 -fno-autolink -ferror-limit 19 -pthread -fgnuc-version=4.2.1 -fcolor-diagnostics -cuid=805820bbe493b9aa -o axpy-cuda-nvptx64-nvidia-cuda-sm_60.s -x ir axpy-cuda-nvptx64-nvidia-cuda-sm_60.bc
```
这个命令很复杂，生成的nvptx代码如下：
```
//
// Generated by LLVM NVPTX Back-End
//

.version 8.3
.target sm_60
.address_size 64

        // .globl       _Z4axpyfPfS_            // -- Begin function _Z4axpyfPfS_
                                        // @_Z4axpyfPfS_
.visible .entry _Z4axpyfPfS_(
        .param .f32 _Z4axpyfPfS__param_0,
        .param .u64 _Z4axpyfPfS__param_1,
        .param .u64 _Z4axpyfPfS__param_2
)
{
        .reg .b32       %r<2>;
        .reg .f32       %f<4>;
        .reg .b64       %rd<8>;

// %bb.0:                               // %entry
        ld.param.f32    %f1, [_Z4axpyfPfS__param_0];
        ld.param.u64    %rd1, [_Z4axpyfPfS__param_2];
        cvta.to.global.u64      %rd2, %rd1;
        ld.param.u64    %rd3, [_Z4axpyfPfS__param_1];
        cvta.to.global.u64      %rd4, %rd3;
这里直接引用了%tid.x预定义寄存器的值，访问线程块的x维索引
        mov.u32         %r1, %tid.x;
        mul.wide.u32    %rd5, %r1, 4;
        add.s64         %rd6, %rd4, %rd5;
        ld.global.f32   %f2, [%rd6];
        mul.rn.f32      %f3, %f2, %f1;
        add.s64         %rd7, %rd2, %rd5;
        st.global.f32   [%rd7], %f3;
        ret;
                                        // -- End function
}
```
也可以使用如下命令生成nvptx
```
llc -O1 -mcpu=sm_60 -mattr=+ptx83 axpy-cuda-nvptx64-nvidia-cuda-sm_60.bc -o axpy-cuda-nvptx64-nvidia-cuda-sm_60-llc.s
```
但是生成的结果不同，使用-print-after-all打印可以看出，两个过程的优化pass并不相同，特别的clang调用会调用AlwaysInlinerPass，把对函数的调用进行内联，因此clang生成的结果更简单。
llc生成的结果保留了对函数的调用，为了分析的完整性，我们采用llc的过程。
调整一下输入cuda源文件，增加device函数
```
__device__ float multiply(float a, float b) {
  return a * b;
}
__global__ void axpy(float a, float* x, float* y) {
  y[threadIdx.x] = multiply(a, x[threadIdx.x]);
}
```
后面可能用到的命令
```
llc -O1 -mcpu=sm_60 -mattr=+ptx83 axpy-cuda-nvptx64-nvidia-cuda-sm_60.bc -debug-only=isel -o axpy-cuda-nvptx64-nvidia-cuda-sm_60-llc.s
llc -O1 -mcpu=sm_60 -mattr=+ptx83 axpy-cuda-nvptx64-nvidia-cuda-sm_60.bc -print-after-all -o axpy-cuda-nvptx64-nvidia-cuda-sm_60-llc.s
llc -O1 -mcpu=sm_60 -mattr=+ptx83 axpy-cuda-nvptx64-nvidia-cuda-sm_60.bc -view-dag-combine1-dags -o axpy-cuda-nvptx64-nvidia-cuda-sm_60-llc.s
```
## nvptx后端分析 - 完整的遍表结构
检查后端的PASS
```
llc -O1 -mcpu=sm_60 -mattr=+ptx83 axpy-cuda-nvptx64-nvidia-cuda-sm_60.bc -debug-pass=Structure -o axpy-cuda-nvptx64-nvidia-cuda-sm_60-llc.s
```
```
Pass Arguments:  -targetlibinfo -targetpassconfig -machinemoduleinfo -tti -nvptx-aa -external-aa -assumption-cache-tracker -tbaa -scoped-noalias-aa -profile-summary-info -collector-metadata -machine-branch-prob -pre-isel-intrinsic-lowering -expand-large-div-rem -expand-large-fp-convert -nvvm-reflect -nvptx-assign-valid-global-names -generic-to-nvvm -nvptx-lower-args -domtree -sroa -nvptx-lower-alloca -infer-address-spaces -nvptx-atomic-lower -domtree -loops -separate-const-offset-from-gep -speculative-execution -scalar-evolution -slsr -early-cse -scalar-evolution -nary-reassociate -early-cse -atomic-expand -nvptx-lower-ctor-dtor -verify -domtree -basic-aa -loops -loop-simplify -scalar-evolution -canon-freeze -iv-users -loop-reduce -basic-aa -aa -mergeicmps -loops -lazy-branch-prob -lazy-block-freq -expand-memcmp -gc-lowering -shadow-stack-gc-lowering -lower-constant-intrinsics -unreachableblockelim -loops -postdomtree -branch-prob -block-freq -consthoist -replace-with-veclib -partially-inline-libcalls -expandvp -scalarize-masked-mem-intrin -expand-reductions -loops -tlshoist -early-cse -basic-aa -aa -scalar-evolution -load-store-vectorizer -sroa -nvptx-lower-unreachable -domtree -loops -codegenprepare -lowerinvoke -unreachableblockelim -callbrprepare -safe-stack -stack-protector -verify -nvptx-lower-aggr-copies -alloca-hoisting -domtree -basic-aa -aa -loops -postdomtree -branch-prob -debug-ata -lazy-branch-prob -lazy-block-freq -nvptx-isel -finalize-isel -lazy-machine-block-freq -early-tailduplication -opt-phis -slotindexes -stack-coloring -localstackalloc -dead-mi-elimination -machinedomtree -machine-loops -machine-block-freq -early-machinelicm -machinedomtree -machine-block-freq -machine-cse -machinepostdomtree -machine-cycles -machine-sink -peephole-opt -nvptx-proxyreg-erasure -processimpdefs -unreachable-mbb-elimination -livevars -machinedomtree -machine-loops -phi-node-elimination -twoaddressinstruction -slotindexes -liveintervals -register-coalescer -machine-scheduler -livestacks -machine-block-freq -stack-slot-coloring -nvptx-peephole -removeredundantdebugvalues -fixup-statepoint-caller-saved -machinedomtree -machine-loops -machine-block-freq -branch-folder -postrapseudos -gc-analysis -machinedomtree -machine-loops -machine-block-freq -machinepostdomtree -block-placement -fentry-insert -xray-instrumentation -machine-sanmd -lazy-machine-block-freq -machine-opt-remark-emitter -stack-frame-layout -machinedomtree -machine-loops
Target Library Information
Target Pass Configuration
Machine Module Information
Target Transform Information
NVPTX Address space based Alias Analysis
External Alias Analysis
Assumption Cache Tracker
Type-Based Alias Analysis
Scoped NoAlias Alias Analysis
Profile summary info
Create Garbage Collector Module Metadata
Machine Branch Probability Analysis
  ModulePass Manager
    Pre-ISel Intrinsic Lowering
    FunctionPass Manager
      Expand large div/rem
      Expand large fp convert
      Replace occurrences of __nvvm_reflect() calls with 0/1
      NVPTX Image Optimizer
    Assign valid PTX names to globals
    Ensure that the global variables are in the global address space
    FunctionPass Manager
      Lower pointer arguments of CUDA kernels
      Dominator Tree Construction
      SROA
      convert address space of alloca'ed memory to local
      Infer address spaces
      NVPTX lower atomics of local memory
      Dominator Tree Construction
      Natural Loop Information
      Split GEPs to a variadic base and a constant offset for better CSE
      Speculatively execute instructions
      Scalar Evolution Analysis
      Straight line strength reduction
      Early CSE
      Scalar Evolution Analysis
      Nary reassociation
      Early CSE
      Expand Atomic instructions
    Lower ctors and dtors for NVPTX
    FunctionPass Manager
      Module Verifier
      Dominator Tree Construction
      Basic Alias Analysis (stateless AA impl)
      Natural Loop Information
      Canonicalize natural loops
      Scalar Evolution Analysis
      Loop Pass Manager
        Canonicalize Freeze Instructions in Loops
        Induction Variable Users
        Loop Strength Reduction
      Basic Alias Analysis (stateless AA impl)
      Function Alias Analysis Results
      Merge contiguous icmps into a memcmp
      Natural Loop Information
      Lazy Branch Probability Analysis
      Lazy Block Frequency Analysis
      Expand memcmp() to load/stores
      Lower Garbage Collection Instructions
      Shadow Stack GC Lowering
      Lower constant intrinsics
      Remove unreachable blocks from the CFG
      Natural Loop Information
      Post-Dominator Tree Construction
      Branch Probability Analysis
      Block Frequency Analysis
      Constant Hoisting
      Replace intrinsics with calls to vector library
      Partially inline calls to library functions
      Expand vector predication intrinsics
      Scalarize Masked Memory Intrinsics
      Expand reduction intrinsics
      Natural Loop Information
      TLS Variable Hoist
      Early CSE
      Basic Alias Analysis (stateless AA impl)
      Function Alias Analysis Results
      Scalar Evolution Analysis
      GPU Load and Store Vectorizer
      SROA
      add an exit instruction before every unreachable
      Dominator Tree Construction
      Natural Loop Information
      CodeGen Prepare
      Lower invoke and unwind, for unwindless code generators
      Remove unreachable blocks from the CFG
      Prepare callbr
      Safe Stack instrumentation pass
      Insert stack protectors
      Module Verifier
      Lower aggregate copies/intrinsics into loops
      NVPTX specific alloca hoisting
      Dominator Tree Construction
      Basic Alias Analysis (stateless AA impl)
      Function Alias Analysis Results
      Natural Loop Information
      Post-Dominator Tree Construction
      Branch Probability Analysis
      Assignment Tracking Analysis
      Lazy Branch Probability Analysis
      Lazy Block Frequency Analysis
      NVPTX DAG->DAG Pattern Instruction Selection
      Finalize ISel and expand pseudo-instructions
      Lazy Machine Block Frequency Analysis
      Early Tail Duplication
      Optimize machine instruction PHIs
      Slot index numbering
      Merge disjoint stack slots
      Local Stack Slot Allocation
      Remove dead machine instructions
      MachineDominator Tree Construction
      Machine Natural Loop Construction
      Machine Block Frequency Analysis
      Early Machine Loop Invariant Code Motion
      MachineDominator Tree Construction
      Machine Block Frequency Analysis
      Machine Common Subexpression Elimination
      MachinePostDominator Tree Construction
      Machine Cycle Info Analysis
      Machine code sinking
      Peephole Optimizations
      NVPTX Proxy Register Instruction Erasure
      Process Implicit Definitions
      Remove unreachable machine basic blocks
      Live Variable Analysis
      MachineDominator Tree Construction
      Machine Natural Loop Construction
      Eliminate PHI nodes for register allocation
      Two-Address instruction pass
      Slot index numbering
      Live Interval Analysis
      Register Coalescer
      Machine Instruction Scheduler
      Live Stack Slot Analysis
      Machine Block Frequency Analysis
      Stack Slot Coloring
      NVPTX Prolog Epilog Pass
      NVPTX optimize redundant cvta.to.local instruction
      Remove Redundant DEBUG_VALUE analysis
      Fixup Statepoint Caller Saved
      MachineDominator Tree Construction
      Machine Natural Loop Construction
      Machine Block Frequency Analysis
      Control Flow Optimizer
      Post-RA pseudo instruction expansion pass
      Analyze Machine Code For Garbage Collection
      MachineDominator Tree Construction
      Machine Natural Loop Construction
      Machine Block Frequency Analysis
      MachinePostDominator Tree Construction
      Branch Probability Basic Block Placement
      Insert fentry calls
      Insert XRay ops
      Machine Sanitizer Binary Metadata
      Lazy Machine Block Frequency Analysis
      Machine Optimization Remark Emitter
      Stack Frame Layout Analysis
      MachineDominator Tree Construction
      Machine Natural Loop Construction
      NVPTX Assembly Printer
      Free MachineFunction
```
后端考虑根据遍情况，从前向后分析编译过程，尤其是有些有趣的遍可以重点分析一下。
## 如何增加PASS结构
llvm/tools/llc/llc.cpp
```
定义PASS管理结构，增加所有PASS
645   // Build up all of the passes that we want to do to the module.
646   legacy::PassManager PM;
增加一个PASS
654   PM.add(new TargetLibraryInfoWrapperPass(TLII));
```
TargetLibraryInfoWrapperPass也是一个PASS类型，这里调用了
```
633   explicit TargetLibraryInfoWrapperPass(const TargetLibraryInfoImpl &TLI);

1363 TargetLibraryInfoWrapperPass::TargetLibraryInfoWrapperPass(
1364     const TargetLibraryInfoImpl &TLIImpl)
1365     : ImmutablePass(ID), TLA(TLIImpl) {
1366   initializeTargetLibraryInfoWrapperPassPass(*PassRegistry::getPassRegistry());
1367 }
```
initializeTargetLibraryInfoWrapperPassPasss是类定义时定义的函数，通过如下方式
```
1371 // Register the basic pass.
1372 INITIALIZE_PASS(TargetLibraryInfoWrapperPass, "targetlibinfo",
1373                 "Target Library Information", false, true)
```
INITIALIZE_PASS定义了函数initializeTargetLibraryInfoWrapperPassPasss
```
这里第三个参数是名字name信息
 38 #define INITIALIZE_PASS(passName, arg, name, cfg, analysis)                    \
 39   static void *initialize##passName##PassOnce(PassRegistry &Registry) {        \
新建一个PassInfo数据结构
 40     PassInfo *PI = new PassInfo(                                               \
 41         name, arg, &passName::ID,                                              \
 42         PassInfo::NormalCtor_t(callDefaultCtor<passName>), cfg, analysis);     \
并且登记到Registry中
 43     Registry.registerPass(*PI, true);                                          \
返回PassInfo数据结构指针
 44     return PI;                                                                 \
 45   }                                                                            \
 46   static llvm::once_flag Initialize##passName##PassFlag;                       \
这里定义了上面的函数，调用前面PassOnce一次。
 47   void llvm::initialize##passName##Pass(PassRegistry &Registry) {              \
 48     llvm::call_once(Initialize##passName##PassFlag,                            \
 49                     initialize##passName##PassOnce, std::ref(Registry));       \
 50   }
```
```
#0  addPassesToGenerateCode (TM=..., PM=..., DisableVerify=85, MMIWP=...) at /home/yhz/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp:118
#1  0x000055555779de5e in llvm::LLVMTargetMachine::addPassesToEmitFile (this=0x7ffff7a18010, PM=..., Out=..., DwoOut=0x0,
    FileType=llvm::CodeGenFileType::AssemblyFile, DisableVerify=false, MMIWP=0x55555be71020)
    at /home/yhz/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp:241
#2  0x0000555556998333 in compileModule (argv=0x7fffffffdf68, Context=...) at /home/yhz/llvm-project/llvm/tools/llc/llc.cpp:720
#3  0x000055555699601a in main (argc=8, argv=0x7fffffffdf68) at /home/yhz/llvm-project/llvm/tools/llc/llc.cpp:425
```
这里检查后端增加了那些PASS
lib/CodeGen/LLVMTargetMachine.cpp
```
114 /// addPassesToX helper drives creation and initialization of TargetPassConfig.
115 static TargetPassConfig *
116 addPassesToGenerateCode(LLVMTargetMachine &TM, PassManagerBase &PM,
117                         bool DisableVerify,
118                         MachineModuleInfoWrapperPass &MMIWP) {
119   // Targets may override createPassConfig to provide a target-specific
120   // subclass.
这里实际调用的NVPTXTargetMachine子类的函数createPassConfig，定义在llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp
实际返回的TargetPassConfig类型是子类NVPTXPassConfig
121   TargetPassConfig *PassConfig = TM.createPassConfig(PM);
```
llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp
```
213 TargetPassConfig *NVPTXTargetMachine::createPassConfig(PassManagerBase &PM) {
214   return new NVPTXPassConfig(*this, PM);
215 }
```
返回addPassesToGenerateCode
```
PassConfig本身也是一个PASS
124   PM.add(PassConfig);
```
