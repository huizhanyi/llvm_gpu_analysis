bitcode文件生成后，经过优化进入后端，这是bitcode文件到ptx文件的生成过程
clang的生成过程使用如下的命令：
```
"/home/yhz/llvm-project/build-debug/bin/clang-18" -cc1 -triple nvptx64-nvidia-cuda -aux-triple x86_64-unknown-linux-gnu -S -dumpdir axpy- -save-temps=cwd -disable-free -clear-ast-before-backend -main-file-name axpy.cu -mrelocation-model static -mframe-pointer=all -fno-rounding-math -no-integrated-as -aux-target-cpu x86-64 -fcuda-is-device -mllvm -enable-memcpyopt-without-libcalls -fcuda-allow-variadic-functions -mlink-builtin-bitcode /usr/local/cuda-12.3/nvvm/libdevice/libdevice.10.bc -target-sdk-version=12.3 -target-cpu sm_60 -target-feature +ptx83 -debugger-tuning=gdb -fno-dwarf-directory-asm -fdebug-compilation-dir=/home/yhz/cuda -v -resource-dir /home/yhz/llvm-project/build-debug/lib/clang/18 -fno-autolink -ferror-limit 19 -pthread -fgnuc-version=4.2.1 -fcolor-diagnostics -cuid=805820bbe493b9aa -o axpy-cuda-nvptx64-nvidia-cuda-sm_60.s -x ir axpy-cuda-nvptx64-nvidia-cuda-sm_60.bc
```
这个命令很复杂，生成的nvptx代码如下：
```
//
// Generated by LLVM NVPTX Back-End
//

.version 8.3
.target sm_60
.address_size 64

        // .globl       _Z4axpyfPfS_            // -- Begin function _Z4axpyfPfS_
                                        // @_Z4axpyfPfS_
.visible .entry _Z4axpyfPfS_(
        .param .f32 _Z4axpyfPfS__param_0,
        .param .u64 _Z4axpyfPfS__param_1,
        .param .u64 _Z4axpyfPfS__param_2
)
{
        .reg .b32       %r<2>;
        .reg .f32       %f<4>;
        .reg .b64       %rd<8>;

// %bb.0:                               // %entry
        ld.param.f32    %f1, [_Z4axpyfPfS__param_0];
        ld.param.u64    %rd1, [_Z4axpyfPfS__param_2];
        cvta.to.global.u64      %rd2, %rd1;
        ld.param.u64    %rd3, [_Z4axpyfPfS__param_1];
        cvta.to.global.u64      %rd4, %rd3;
这里直接引用了%tid.x预定义寄存器的值，访问线程块的x维索引
        mov.u32         %r1, %tid.x;
        mul.wide.u32    %rd5, %r1, 4;
        add.s64         %rd6, %rd4, %rd5;
        ld.global.f32   %f2, [%rd6];
        mul.rn.f32      %f3, %f2, %f1;
        add.s64         %rd7, %rd2, %rd5;
        st.global.f32   [%rd7], %f3;
        ret;
                                        // -- End function
}
```
也可以使用如下命令生成nvptx
```
llc -O1 -mcpu=sm_60 -mattr=+ptx83 axpy-cuda-nvptx64-nvidia-cuda-sm_60.bc -o axpy-cuda-nvptx64-nvidia-cuda-sm_60-llc.s
```
但是生成的结果不同，使用-print-after-all打印可以看出，两个过程的优化pass并不相同，特别的clang调用会调用AlwaysInlinerPass，把对函数的调用进行内联，因此clang生成的结果更简单。
llc生成的结果保留了对函数的调用，为了分析的完整性，我们采用llc的过程。
调整一下输入cuda源文件，增加device函数
```
__device__ float multiply(float a, float b) {
  return a * b;
}
__global__ void axpy(float a, float* x, float* y) {
  y[threadIdx.x] = multiply(a, x[threadIdx.x]);
}
```
