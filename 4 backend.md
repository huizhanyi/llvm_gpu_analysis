## 引言
bitcode文件生成后，经过优化进入后端，这是bitcode文件到ptx文件的生成过程
clang的生成过程使用如下的命令：
```
"/home/yhz/llvm-project/build-debug/bin/clang-18" -cc1 -triple nvptx64-nvidia-cuda -aux-triple x86_64-unknown-linux-gnu -S -dumpdir axpy- -save-temps=cwd -disable-free -clear-ast-before-backend -main-file-name axpy.cu -mrelocation-model static -mframe-pointer=all -fno-rounding-math -no-integrated-as -aux-target-cpu x86-64 -fcuda-is-device -mllvm -enable-memcpyopt-without-libcalls -fcuda-allow-variadic-functions -mlink-builtin-bitcode /usr/local/cuda-12.3/nvvm/libdevice/libdevice.10.bc -target-sdk-version=12.3 -target-cpu sm_60 -target-feature +ptx83 -debugger-tuning=gdb -fno-dwarf-directory-asm -fdebug-compilation-dir=/home/yhz/cuda -v -resource-dir /home/yhz/llvm-project/build-debug/lib/clang/18 -fno-autolink -ferror-limit 19 -pthread -fgnuc-version=4.2.1 -fcolor-diagnostics -cuid=805820bbe493b9aa -o axpy-cuda-nvptx64-nvidia-cuda-sm_60.s -x ir axpy-cuda-nvptx64-nvidia-cuda-sm_60.bc
```
这个命令很复杂，生成的nvptx代码如下：
```
//
// Generated by LLVM NVPTX Back-End
//

.version 8.3
.target sm_60
.address_size 64

        // .globl       _Z4axpyfPfS_            // -- Begin function _Z4axpyfPfS_
                                        // @_Z4axpyfPfS_
.visible .entry _Z4axpyfPfS_(
        .param .f32 _Z4axpyfPfS__param_0,
        .param .u64 _Z4axpyfPfS__param_1,
        .param .u64 _Z4axpyfPfS__param_2
)
{
        .reg .b32       %r<2>;
        .reg .f32       %f<4>;
        .reg .b64       %rd<8>;

// %bb.0:                               // %entry
        ld.param.f32    %f1, [_Z4axpyfPfS__param_0];
        ld.param.u64    %rd1, [_Z4axpyfPfS__param_2];
        cvta.to.global.u64      %rd2, %rd1;
        ld.param.u64    %rd3, [_Z4axpyfPfS__param_1];
        cvta.to.global.u64      %rd4, %rd3;
这里直接引用了%tid.x预定义寄存器的值，访问线程块的x维索引
        mov.u32         %r1, %tid.x;
        mul.wide.u32    %rd5, %r1, 4;
        add.s64         %rd6, %rd4, %rd5;
        ld.global.f32   %f2, [%rd6];
        mul.rn.f32      %f3, %f2, %f1;
        add.s64         %rd7, %rd2, %rd5;
        st.global.f32   [%rd7], %f3;
        ret;
                                        // -- End function
}
```
也可以使用如下命令生成nvptx
```
llc -O1 -mcpu=sm_60 -mattr=+ptx83 axpy-cuda-nvptx64-nvidia-cuda-sm_60.bc -o axpy-cuda-nvptx64-nvidia-cuda-sm_60-llc.s
```
但是生成的结果不同，使用-print-after-all打印可以看出，两个过程的优化pass并不相同，特别的clang调用会调用AlwaysInlinerPass，把对函数的调用进行内联，因此clang生成的结果更简单。
llc生成的结果保留了对函数的调用，为了分析的完整性，我们采用llc的过程。
调整一下输入cuda源文件，增加device函数
```
__device__ float multiply(float a, float b) {
  return a * b;
}
__global__ void axpy(float a, float* x, float* y) {
  y[threadIdx.x] = multiply(a, x[threadIdx.x]);
}
```
后面可能用到的命令
```
llc -O1 -mcpu=sm_60 -mattr=+ptx83 axpy-cuda-nvptx64-nvidia-cuda-sm_60.bc -debug-only=isel -o axpy-cuda-nvptx64-nvidia-cuda-sm_60-llc.s
llc -O1 -mcpu=sm_60 -mattr=+ptx83 axpy-cuda-nvptx64-nvidia-cuda-sm_60.bc -print-after-all -o axpy-cuda-nvptx64-nvidia-cuda-sm_60-llc.s
llc -O1 -mcpu=sm_60 -mattr=+ptx83 axpy-cuda-nvptx64-nvidia-cuda-sm_60.bc -view-dag-combine1-dags -o axpy-cuda-nvptx64-nvidia-cuda-sm_60-llc.s
```
## nvptx后端分析 - 完整的遍表结构
检查后端的PASS
```
llc -O1 -mcpu=sm_60 -mattr=+ptx83 axpy-cuda-nvptx64-nvidia-cuda-sm_60.bc -debug-pass=Structure -o axpy-cuda-nvptx64-nvidia-cuda-sm_60-llc.s
```
```
Pass Arguments:  -targetlibinfo -targetpassconfig -machinemoduleinfo -tti -nvptx-aa -external-aa -assumption-cache-tracker -tbaa -scoped-noalias-aa -profile-summary-info -collector-metadata -machine-branch-prob -pre-isel-intrinsic-lowering -expand-large-div-rem -expand-large-fp-convert -nvvm-reflect -nvptx-assign-valid-global-names -generic-to-nvvm -nvptx-lower-args -domtree -sroa -nvptx-lower-alloca -infer-address-spaces -nvptx-atomic-lower -domtree -loops -separate-const-offset-from-gep -speculative-execution -scalar-evolution -slsr -early-cse -scalar-evolution -nary-reassociate -early-cse -atomic-expand -nvptx-lower-ctor-dtor -verify -domtree -basic-aa -loops -loop-simplify -scalar-evolution -canon-freeze -iv-users -loop-reduce -basic-aa -aa -mergeicmps -loops -lazy-branch-prob -lazy-block-freq -expand-memcmp -gc-lowering -shadow-stack-gc-lowering -lower-constant-intrinsics -unreachableblockelim -loops -postdomtree -branch-prob -block-freq -consthoist -replace-with-veclib -partially-inline-libcalls -expandvp -scalarize-masked-mem-intrin -expand-reductions -loops -tlshoist -early-cse -basic-aa -aa -scalar-evolution -load-store-vectorizer -sroa -nvptx-lower-unreachable -domtree -loops -codegenprepare -lowerinvoke -unreachableblockelim -callbrprepare -safe-stack -stack-protector -verify -nvptx-lower-aggr-copies -alloca-hoisting -domtree -basic-aa -aa -loops -postdomtree -branch-prob -debug-ata -lazy-branch-prob -lazy-block-freq -nvptx-isel -finalize-isel -lazy-machine-block-freq -early-tailduplication -opt-phis -slotindexes -stack-coloring -localstackalloc -dead-mi-elimination -machinedomtree -machine-loops -machine-block-freq -early-machinelicm -machinedomtree -machine-block-freq -machine-cse -machinepostdomtree -machine-cycles -machine-sink -peephole-opt -nvptx-proxyreg-erasure -processimpdefs -unreachable-mbb-elimination -livevars -machinedomtree -machine-loops -phi-node-elimination -twoaddressinstruction -slotindexes -liveintervals -register-coalescer -machine-scheduler -livestacks -machine-block-freq -stack-slot-coloring -nvptx-peephole -removeredundantdebugvalues -fixup-statepoint-caller-saved -machinedomtree -machine-loops -machine-block-freq -branch-folder -postrapseudos -gc-analysis -machinedomtree -machine-loops -machine-block-freq -machinepostdomtree -block-placement -fentry-insert -xray-instrumentation -machine-sanmd -lazy-machine-block-freq -machine-opt-remark-emitter -stack-frame-layout -machinedomtree -machine-loops
这是第一个PASS，提供当前目标可用的库信息
Target Library Information
这是第二个PASS，完成对Target相关PASS配置的初始化
Target Pass Configuration
Machine Module Information
Target Transform Information
NVPTX Address space based Alias Analysis
由createExternalAAWrapperPass生成，这里添加了一个NVPTX的定制NVPTXAAWrapperPass
External Alias Analysis
Assumption Cache Tracker
Type-Based Alias Analysis
Scoped NoAlias Alias Analysis
Profile summary info
Create Garbage Collector Module Metadata
Machine Branch Probability Analysis
这之前的PASS都是ImmutablePass类型PASS，优先放在了前面。

  ModulePass Manager
这是对应到createPreISelIntrinsicLoweringPass生成PASS
    Pre-ISel Intrinsic Lowering
    FunctionPass Manager
createExpandLargeDivRemPass生成PASS
      Expand large div/rem
createExpandLargeFpConvertPass生成PASS
      Expand large fp convert
addIRPasses -> 
      Replace occurrences of __nvvm_reflect() calls with 0/1
      NVPTX Image Optimizer
    Assign valid PTX names to globals
    Ensure that the global variables are in the global address space
    FunctionPass Manager
      Lower pointer arguments of CUDA kernels
      Dominator Tree Construction
      SROA
      convert address space of alloca'ed memory to local
      Infer address spaces
      NVPTX lower atomics of local memory
      Dominator Tree Construction
      Natural Loop Information
      Split GEPs to a variadic base and a constant offset for better CSE
      Speculatively execute instructions
      Scalar Evolution Analysis
      Straight line strength reduction
      Early CSE
      Scalar Evolution Analysis
      Nary reassociation
      Early CSE
      Expand Atomic instructions
    Lower ctors and dtors for NVPTX
    FunctionPass Manager
      Module Verifier
      Dominator Tree Construction
      Basic Alias Analysis (stateless AA impl)
      Natural Loop Information
      Canonicalize natural loops
      Scalar Evolution Analysis
      Loop Pass Manager
        Canonicalize Freeze Instructions in Loops
        Induction Variable Users
        Loop Strength Reduction
      Basic Alias Analysis (stateless AA impl)
      Function Alias Analysis Results
      Merge contiguous icmps into a memcmp
      Natural Loop Information
      Lazy Branch Probability Analysis
      Lazy Block Frequency Analysis
      Expand memcmp() to load/stores
      Lower Garbage Collection Instructions
      Shadow Stack GC Lowering
      Lower constant intrinsics
      Remove unreachable blocks from the CFG
      Natural Loop Information
      Post-Dominator Tree Construction
      Branch Probability Analysis
      Block Frequency Analysis
      Constant Hoisting
      Replace intrinsics with calls to vector library
      Partially inline calls to library functions
      Expand vector predication intrinsics
      Scalarize Masked Memory Intrinsics
      Expand reduction intrinsics
      Natural Loop Information
      TLS Variable Hoist
      Early CSE
      Basic Alias Analysis (stateless AA impl)
      Function Alias Analysis Results
      Scalar Evolution Analysis
      GPU Load and Store Vectorizer
      SROA
      add an exit instruction before every unreachable
      Dominator Tree Construction
      Natural Loop Information
      CodeGen Prepare
      Lower invoke and unwind, for unwindless code generators
      Remove unreachable blocks from the CFG
      Prepare callbr
      Safe Stack instrumentation pass
      Insert stack protectors
      Module Verifier
      Lower aggregate copies/intrinsics into loops
      NVPTX specific alloca hoisting
      Dominator Tree Construction
      Basic Alias Analysis (stateless AA impl)
      Function Alias Analysis Results
      Natural Loop Information
      Post-Dominator Tree Construction
      Branch Probability Analysis
      Assignment Tracking Analysis
      Lazy Branch Probability Analysis
      Lazy Block Frequency Analysis
      NVPTX DAG->DAG Pattern Instruction Selection
      Finalize ISel and expand pseudo-instructions
      Lazy Machine Block Frequency Analysis
      Early Tail Duplication
      Optimize machine instruction PHIs
      Slot index numbering
      Merge disjoint stack slots
      Local Stack Slot Allocation
      Remove dead machine instructions
      MachineDominator Tree Construction
      Machine Natural Loop Construction
      Machine Block Frequency Analysis
      Early Machine Loop Invariant Code Motion
      MachineDominator Tree Construction
      Machine Block Frequency Analysis
      Machine Common Subexpression Elimination
      MachinePostDominator Tree Construction
      Machine Cycle Info Analysis
      Machine code sinking
      Peephole Optimizations
      NVPTX Proxy Register Instruction Erasure
      Process Implicit Definitions
      Remove unreachable machine basic blocks
      Live Variable Analysis
      MachineDominator Tree Construction
      Machine Natural Loop Construction
      Eliminate PHI nodes for register allocation
      Two-Address instruction pass
      Slot index numbering
      Live Interval Analysis
      Register Coalescer
      Machine Instruction Scheduler
      Live Stack Slot Analysis
      Machine Block Frequency Analysis
      Stack Slot Coloring
      NVPTX Prolog Epilog Pass
      NVPTX optimize redundant cvta.to.local instruction
      Remove Redundant DEBUG_VALUE analysis
      Fixup Statepoint Caller Saved
      MachineDominator Tree Construction
      Machine Natural Loop Construction
      Machine Block Frequency Analysis
      Control Flow Optimizer
      Post-RA pseudo instruction expansion pass
      Analyze Machine Code For Garbage Collection
      MachineDominator Tree Construction
      Machine Natural Loop Construction
      Machine Block Frequency Analysis
      MachinePostDominator Tree Construction
      Branch Probability Basic Block Placement
      Insert fentry calls
      Insert XRay ops
      Machine Sanitizer Binary Metadata
      Lazy Machine Block Frequency Analysis
      Machine Optimization Remark Emitter
      Stack Frame Layout Analysis
      MachineDominator Tree Construction
      Machine Natural Loop Construction
      NVPTX Assembly Printer
      Free MachineFunction
```
后端考虑根据遍情况，从前向后分析编译过程，尤其是有些有趣的遍可以重点分析一下。
## 如何增加PASS结构
### 第一个PASS "Target Library Information"
llvm/tools/llc/llc.cpp
```
定义PASS管理结构，增加所有PASS
645   // Build up all of the passes that we want to do to the module.
646   legacy::PassManager PM;
648   // Add an appropriate TargetLibraryInfo pass for the module's triple.
返回Triple信息，实现TargetLibraryInfoImpl结构
649   TargetLibraryInfoImpl TLII(Triple(M->getTargetTriple()));
增加一个PASS，提供当前目标可用的库信息
654   PM.add(new TargetLibraryInfoWrapperPass(TLII));
```
这里getTargetTriple返回TargetTriple，这是通过M->setTargetTriple设置的。对于nvptx后端为"nvptx64-nvidia-cuda"
Triple构建Triple结构，用于初始化TargetLibraryInfoImpl
```
 891 TargetLibraryInfoImpl::TargetLibraryInfoImpl(const Triple &T) {
 892   // Default to everything being available.
 893   memset(AvailableArray, -1, sizeof(AvailableArray));
 894
 895   initialize(*this, T, StandardNames);
 896 }
```
这里调用了initialize定义为llvm/lib/Analysis/TargetLibraryInfo.cpp
```
 161 /// Initialize the set of available library functions based on the specified
 162 /// target triple. This should be carefully written so that a missing target
 163 /// triple gets a sane set of defaults.
 164 static void initialize(TargetLibraryInfoImpl &TLI, const Triple &T,
 165                        ArrayRef<StringLiteral> StandardNames) {
根据Triple初始化可用的库函数
 842   // As currently implemented in clang, NVPTX code has no standard library to
 843   // speak of.  Headers provide a standard-ish library implementation, but many
 844   // of the signatures are wrong -- for example, many libm functions are not
 845   // extern "C".
 846   //
 847   // libdevice, an IR library provided by nvidia, is linked in by the front-end,
 848   // but only used functions are provided to llvm.  Moreover, most of the
 849   // functions in libdevice don't map precisely to standard library functions.
 850   //
 851   // FIXME: Having no standard library prevents e.g. many fastmath
 852   // optimizations, so this situation should be fixed.
这里根据NVPTX后端设置了一些可用的库函数
 853   if (T.isNVPTX()) {
 854     TLI.disableAllFunctions();
 855     TLI.setAvailable(LibFunc_nvvm_reflect);
 856     TLI.setAvailable(llvm::LibFunc_malloc);
 857     TLI.setAvailable(llvm::LibFunc_free);
 858
 859     // TODO: We could enable the following two according to [0] but we haven't
 860     //       done an evaluation wrt. the performance implications.
 861     // [0]
 862     // https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#dynamic-global-memory-allocation-and-operations
 863     //
 864     //    TLI.setAvailable(llvm::LibFunc_memcpy);
 865     //    TLI.setAvailable(llvm::LibFunc_memset);
 866
 867     TLI.setAvailable(llvm::LibFunc___kmpc_alloc_shared);
 868     TLI.setAvailable(llvm::LibFunc___kmpc_free_shared);
 869   } else {
 870     TLI.setUnavailable(LibFunc_nvvm_reflect);
 871   }
```
这里看在TargetLibraryInfoImpl定义了可用的库函数信息。

TargetLibraryInfoWrapperPass也是一个PASS类型，是第一个PASS,这里调用了
```
633   explicit TargetLibraryInfoWrapperPass(const TargetLibraryInfoImpl &TLI);

1363 TargetLibraryInfoWrapperPass::TargetLibraryInfoWrapperPass(
1364     const TargetLibraryInfoImpl &TLIImpl)
1365     : ImmutablePass(ID), TLA(TLIImpl) {
1366   initializeTargetLibraryInfoWrapperPassPass(*PassRegistry::getPassRegistry());
1367 }
```
initializeTargetLibraryInfoWrapperPassPasss是类定义时定义的函数，通过如下方式
```
1371 // Register the basic pass.
1372 INITIALIZE_PASS(TargetLibraryInfoWrapperPass, "targetlibinfo",
1373                 "Target Library Information", false, true)
```
INITIALIZE_PASS定义了函数initializeTargetLibraryInfoWrapperPassPasss
```
这里第三个参数是名字name信息,对应PASS的名字，因此第一个PASS的名字是"Target Library Information"
 38 #define INITIALIZE_PASS(passName, arg, name, cfg, analysis)                    \
 39   static void *initialize##passName##PassOnce(PassRegistry &Registry) {        \
新建一个PassInfo数据结构
 40     PassInfo *PI = new PassInfo(                                               \
 41         name, arg, &passName::ID,                                              \
 42         PassInfo::NormalCtor_t(callDefaultCtor<passName>), cfg, analysis);     \
并且登记到Registry中
 43     Registry.registerPass(*PI, true);                                          \
返回PassInfo数据结构指针
 44     return PI;                                                                 \
 45   }                                                                            \
 46   static llvm::once_flag Initialize##passName##PassFlag;                       \
这里定义了上面的函数，调用前面PassOnce一次。
 47   void llvm::initialize##passName##Pass(PassRegistry &Registry) {              \
 48     llvm::call_once(Initialize##passName##PassFlag,                            \
 49                     initialize##passName##PassOnce, std::ref(Registry));       \
 50   }
```
### 第二个PASS "Target Pass Configuration"
```
#0  addPassesToGenerateCode (TM=..., PM=..., DisableVerify=85, MMIWP=...) at /home/yhz/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp:118
#1  0x000055555779de5e in llvm::LLVMTargetMachine::addPassesToEmitFile (this=0x7ffff7a18010, PM=..., Out=..., DwoOut=0x0,
    FileType=llvm::CodeGenFileType::AssemblyFile, DisableVerify=false, MMIWP=0x55555be71020)
    at /home/yhz/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp:241
#2  0x0000555556998333 in compileModule (argv=0x7fffffffdf68, Context=...) at /home/yhz/llvm-project/llvm/tools/llc/llc.cpp:720
#3  0x000055555699601a in main (argc=8, argv=0x7fffffffdf68) at /home/yhz/llvm-project/llvm/tools/llc/llc.cpp:425
```
这里检查后端增加了那些PASS
lib/CodeGen/LLVMTargetMachine.cpp
```
114 /// addPassesToX helper drives creation and initialization of TargetPassConfig.
115 static TargetPassConfig *
116 addPassesToGenerateCode(LLVMTargetMachine &TM, PassManagerBase &PM,
117                         bool DisableVerify,
118                         MachineModuleInfoWrapperPass &MMIWP) {
119   // Targets may override createPassConfig to provide a target-specific
120   // subclass.
这里实际调用的NVPTXTargetMachine子类的函数createPassConfig，定义在llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp
实际返回的TargetPassConfig类型是子类NVPTXPassConfig，但是类型名字不变"Target Pass Configuration"
121   TargetPassConfig *PassConfig = TM.createPassConfig(PM);
```
llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp
```
213 TargetPassConfig *NVPTXTargetMachine::createPassConfig(PassManagerBase &PM) {
214   return new NVPTXPassConfig(*this, PM);
215 }
```
NVPTXPassConfig调用TargetPassConfig的constructor函数
```
 571 TargetPassConfig::TargetPassConfig(LLVMTargetMachine &TM, PassManagerBase &pm)
 572     : ImmutablePass(ID), PM(&pm), TM(&TM) {
 575   // Register all target independent codegen passes to activate their PassIDs,
 576   // including this pass itself.
 577   initializeCodeGen(*PassRegistry::getPassRegistry());

 19 /// initializeCodeGen - Initialize all passes linked into the CodeGen library.
 20 void llvm::initializeCodeGen(PassRegistry &Registry) {
133   initializeTargetPassConfigPass(Registry);

 353 INITIALIZE_PASS(TargetPassConfig, "targetpassconfig",
 354                 "Target Pass Configuration", false, false)
```
返回addPassesToGenerateCode
```
TargetPassConfig本身也是一个PASS
124   PM.add(PassConfig);
```
因此第二个PASS为"Target Pass Configuration",功能是完成对Target相关PASS配置的初始化

```
125   PM.add(&MMIWP);
```
这里的PASS名称为"Machine Module Information"
```
183 // Handle the Pass registration stuff necessary to use DataLayout's.
184 INITIALIZE_PASS(MachineModuleInfoWrapperPass, "machinemoduleinfo",
185                 "Machine Module Information", false, false)

238   if (!MMIWP)
239     MMIWP = new MachineModuleInfoWrapperPass(this);

171 MachineModuleInfoWrapperPass::MachineModuleInfoWrapperPass(
172     const LLVMTargetMachine *TM)
173     : ImmutablePass(ID), MMI(TM) {
174   initializeMachineModuleInfoWrapperPassPass(*PassRegistry::getPassRegistry());
175 }
```
完成Pass的初始化。
### addISelPasses
```
238   /// High level function that adds all passes necessary to go from llvm IR
239   /// representation to the MI representation.
240   /// Adds IR based lowering and target specific optimization passes and finally
241   /// the core instruction selection passes.
242   /// \returns true if an error occurred, false otherwise.
243   bool addISelPasses();

1054 bool TargetPassConfig::addISelPasses() {
没有使用这个PASS
1055   if (TM->useEmulatedTLS())
1056     addPass(createLowerEmuTLSPass());
1057
PASS "Target Transform Information"，ImmutablePass，直接增加到PASS 管理器
1058   PM->add(createTargetTransformInfoWrapperPass(TM->getTargetIRAnalysis()));
PreISelIntrinsicLoweringLegacyPasss是ModulePass类型，看遍表的打印结果，ModulePass在ImmutablePass后面，不清楚是调用确实存在先后，还是遍表打印过程分配打印，猜测应该是前者？MPPassManager是一个Pass的子类，本身应该和ImmutablePass优先级相同？
1059   addPass(createPreISelIntrinsicLoweringPass());
这是一个FunctionPass类型Pass，运行在后面。FPPassManager是函数Pass管理器，本身是一个ModulePass。
1060   addPass(createExpandLargeDivRemPass());
这是一个FunctionPass类型Pass
1061   addPass(createExpandLargeFpConvertPass());
这个函数NVPTX后端有自己的定义
1062   addIRPasses();
...
1068 }
```
NVPTXTargetMachine.cpp
```
339 void NVPTXPassConfig::addIRPasses() {
这是ImmutablePass类型PASS,"NVPTX Address space based Alias Analysis"，对应打印遍表的下面的遍。
357   addPass(createNVPTXAAWrapperPass());
358   addPass(createExternalAAWrapperPass([](Pass &P, Function &, AAResults &AAR) {
359     if (auto *WrapperPass = P.getAnalysisIfAvailable<NVPTXAAWrapperPass>())
360       AAR.addAAResult(WrapperPass->getResult());
361   }));

362
363   // NVVMReflectPass is added in addEarlyAsPossiblePasses, so hopefully running
364   // it here does nothing.  But since we need it for correctness when lowering
365   // to NVPTX, run it here too, in case whoever built our pass pipeline didn't
366   // call addEarlyAsPossiblePasses.
367   const NVPTXSubtarget &ST = *getTM<NVPTXTargetMachine>().getSubtargetImpl();
增加一个FunctionPass
368   addPass(createNVVMReflectPass(ST.getSmVersion()));

370   if (getOptLevel() != CodeGenOptLevel::None)
371     addPass(createNVPTXImageOptimizerPass());
另外的FunctionPASS,前面的FunctionPASS都合并到一个FunctionManager中管理
这是一个ModuelPASS
372   addPass(createNVPTXAssignValidGlobalNamesPass());
这是一个ModuelPASS，对应"Ensure that the global variables are in the global address space"
373   addPass(createGenericToNVVMLegacyPass());
```
